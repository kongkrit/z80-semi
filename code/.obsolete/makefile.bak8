# -----------------------------------------------------------------------------
# Tools
# -----------------------------------------------------------------------------
SDAS      := sdasz80
SDCC      := sdcc
SDOBJCOPY := sdobjcopy
Z80DASM   := z80dasm

ASMFLAGS  := -l
CFLAGS    := -mz80 --std c99 --Werror
LDFLAGS   := -mz80 --no-std-crt0

# Cross-platform clean and copy
ifeq ($(COMSPEC)$(ComSpec),)        # empty on Unix
  RM := rm -f
  CP := cp
else
  RM := del /F /Q                   # Windows
  CP := copy /Y
endif

# -----------------------------------------------------------------------------
# Definitions: NNN = 3-digit number, from 000-999
# -----------------------------------------------------------------------------
# Strict scan for [0-9][0-9][0-9]-*.c
PREFIXES := $(sort $(foreach s,$(wildcard [0-9][0-9][0-9]-*.c),$(firstword $(subst -, ,$(s)))))

# -----------------------------------------------------------------------------
# Target: "all"
# -----------------------------------------------------------------------------
# Iterate through all NNN's
all: default-startup.rel default-nmi_handler.rel $(PREFIXES:%=%-run.bin)

# -----------------------------------------------------------------------------
# "Always Do" Rules
# -----------------------------------------------------------------------------
default-startup.rel: default-startup.s
	$(SDAS) $(ASMFLAGS) -o default-startup.rel default-startup.s

default-nmi_handler.rel: default-nmi_handler.c
	$(SDCC) $(CFLAGS) -c default-nmi_handler.c -o default-nmi_handler.rel

# -----------------------------------------------------------------------------
# Generic Compile/Assemble Rules
# -----------------------------------------------------------------------------
%.rel: %.s
	$(SDAS) $(ASMFLAGS) -o $@ $<

%.rel: %.c
	$(SDCC) $(CFLAGS) -c $< -o $@

# -----------------------------------------------------------------------------
# Logic Per NNN Prefix
# -----------------------------------------------------------------------------
define DEFINE_RUN_RULES

# 1. Bomb if NNN-*.c doesn't exist
$(1)_CSRCS := $(wildcard $(1)-*.c)
ifeq ($$($(1)_CSRCS),)
   $$(error Target "$(1)-run.bin" requires sources matching "$(1)-*.c")
endif

# 2. $C_OBJ = NNN-*.rel, except NNN-nmi_handler.rel
$(1)_RAW_RELS := $$($(1)_CSRCS:.c=.rel)
$(1)_C_OBJ    := $(filter-out $(1)-nmi_handler.rel, $$($(1)_RAW_RELS))

# 3. ASM_OBJ Logic
# If NNN-startup.s exists -> use it
# Else -> copy default-startup.rel/.lst to NNN-startup.rel/.lst
ifneq ($(wildcard $(1)-startup.s),)
    # Source exists: use it (relies on generic %.rel: %.s rule)
    $(1)_ASM_OBJ := $(1)-startup.rel
else
    # Assembler output missing: copy default-startup
    $(1)-startup.rel: default-startup.rel
		$$(CP) default-startup.rel $$@
	
    $(1)-startup.lst: default-startup.lst
		$$(CP) default-startup.lst $$@

    $(1)_ASM_OBJ := $(1)-startup.rel
endif

# 4. NMI_HANDLER Logic - grep for "void nmi_handler..." in NNN-*.c files
# grep returns 0 (found) -> NMI_HANDLER is blank
# grep returns 1 (not found) -> copy default to NNN-nmi_handler, set NMI_HANDLER
$(1)_HAS_ISR := $(shell grep -Pzq "void\s+nmi_handler\s*\(\s*(void)?\s*\)\s+__critical\s+__interrupt" $(1)-*.c && echo yes)

ifdef $(1)_HAS_ISR
    # FOUND: User defined ISR
    $(1)_NMI_HANDLER :=
else
    # NOT FOUND: Copy default to NNN-nmi_handler
    $(1)-nmi_handler.rel: default-nmi_handler.rel
		$$(CP) default-nmi_handler.rel $$@

    $(1)-nmi_handler.lst: default-nmi_handler.lst
		$$(CP) default-nmi_handler.lst $$@

    $(1)_NMI_HANDLER := $(1)-nmi_handler.rel
endif

# 5. MEMMAP Logic
# If NNN-memmap.ld exists -> use NNN-memmap.ld, else -> default-memmap.ld
ifneq ($(wildcard $(1)-memmap.ld),)
    $(1)_MEMMAP := $(1)-memmap.ld
else
    $(1)_MEMMAP := default-memmap.ld
endif

# 6. Generate NNN-run.ihx
$(1)-run.ihx: $$($(1)_ASM_OBJ) $$($(1)_C_OBJ) $$($(1)_NMI_HANDLER) $$($(1)_MEMMAP)
	$(SDCC) $(LDFLAGS) $$($(1)_ASM_OBJ) $$($(1)_C_OBJ) $$($(1)_NMI_HANDLER) -Wl-u -Wl-f,$$($(1)_MEMMAP) -o $$@

endef

# Iterate over all detected NNN and evaluate the rules
$(foreach P,$(PREFIXES),$(eval $(call DEFINE_RUN_RULES,$(P))))

# -----------------------------------------------------------------------------
# Post-Processing: IHX -> BIN + Disassembly
# -----------------------------------------------------------------------------
%-run.bin: %-run.ihx
	@echo "Generating Binary and Disassembly for $*..."
	$(SDOBJCOPY) -I ihex -O binary $< $@
	$(Z80DASM) -a -l -t -g0 $@ | \
	awk ' \
	BEGIN { count = 0; } \
	/^[ \t]+nop[ \t]+;[0-9a-fA-F]{4}[ \t]+00.*$$/ { \
		buffer[count++] = $$0; \
		next; \
	} \
	{ \
		if (count > 3) { \
			print buffer[0]; \
			print "    ..."; \
			print buffer[count-1]; \
		} \
		else { for (i=0; i<count; i++) print buffer[i]; } \
		count = 0; \
		print $$0; \
	} \
	END { \
		if (count > 3) { \
			print buffer[0]; \
			print "    ..."; \
			print buffer[count-1]; \
		} \
		else { for (i=0; i<count; i++) print buffer[i]; } \
	}' > $(@:%.bin=%.txs)

# -----------------------------------------------------------------------------
# Clean
# -----------------------------------------------------------------------------
clean:
	$(RM) *.asm *.bin *.ihx *.lk *.lst *.map *.noi *.rel *.rst *.sym *.txs
